âœ… Problem(https://leetcode.com/problems/find-unique-binary-string/description/?envType=daily-question&envId=2025-02-20)
Given n unique binary strings, each of length n, return any binary string of length n that is not in the input list.
Each string in nums contains only '0' or '1'.
You must return a binary string of the same length that is not present in the input list.
Multiple valid answers possible.

âœ… Constraints
1 <= n <= 16 (but think: what if n were larger?)
All strings are unique.
Each string is of length n.

ðŸ”§ Brute Force (Using Frequency Array)
(Question in simple terms)
Youâ€™re given n binary strings of length n.
There are a total of 2â¿ possible binary strings of length n.
But you only have n of them in the input.
So... at least one is missing.
Now the task is to find any one missing string.


1. Understand 
Imagine all possible binary strings of length n.
For example, if n = 2, possible strings are:
00, 01, 10, 11 â†’ total 4 = 2^2

Now suppose the input is ["00", "01"].
Clearly, 10 and 11 are missing.

So brute force says:
Let's go through all 2â¿ strings and check which one is not in the input.


To quickly check if a string is already in the input:

Convert input strings to decimal (e.g., "10" â†’ 2)
Mark them in a bool[] freq of size 2â¿
This makes checking super fast: just freq[i] == true/false
So you loop from i = 0 to 2^n - 1 and ask:
Is i marked? If not, then convert i to binary string â†’ return that.


3. Why It Makes Sense
Because:
You know the total number of possibilities: 2â¿
You know input has only n strings â†’ so n < 2â¿
You want to return any missing string.
So just generate all, and return the first not found.
Thatâ€™s the brute-force intuition.


âœ… Example (n = 3)
Input: ["000", "001", "010"]

All possible 3-bit binary strings:
000 (0), 001 (1), 010 (2), 011 (3), 100 (4), 101 (5), 110 (6), 111 (7)

Now mark 000, 001, 010 as present.

Loop i from 0 to 7:

i = 0 â†’ already there

i = 1 â†’ already there

i = 2 â†’ already there

i = 3 â†’ not marked â†’ convert to binary â†’ "011" â†’ return âœ…

âš ï¸ But Why Is It Called Brute Force?
Because:

You're checking every possible string.
Even though there's a clever trick (diagonal), here you donâ€™t care.
Youâ€™re brute-force checking from 0 to 2â¿, and returning the first valid answer.
Itâ€™s not clever. Itâ€™s guaranteed to work, but not optimal.

CODE=>
//int convertToDecimal(string str) {
//    int ans = 0;
//    for (char c : str) ans = ans * 2 + (c - '0');
//    return ans;
//}
//
//string convertToBinary(int num, int n) {
//   string ans(n, '0');
//    for (int i = n - 1; i >= 0; --i) {
//        ans[i] = (num % 2) + '0';
//        num /= 2;
//    }
//    return ans;
//}
//
//string findDifferentBinaryString(vector<string>& nums) {
//    int n = nums.size();
//    vector<bool> freq(1 << n, false);
//    for (string str : nums) freq[convertToDecimal(str)] = true;
//
//    for (int i = 0; i < (1 << n); i++) {
//        if (!freq[i]) return convertToBinary(i, n);
//    }
//    return "";
//}

ðŸ”¹ Time: O(n * 2^n)
ðŸ”¹ Space: O(2^n)
âœ… Use when: n â‰¤ 16


ðŸ’¡ OPTIMAL APPROACH (CANTOR'S DIAGONALIZATION)
âœ… Core Idea:
Build a new string that differs from the i-th string at its i-th bit.

ðŸ” Why it works:
Guarantees uniqueness: new string â‰  any in input.

Based on diagonal flipping idea from Cantorâ€™s proof.
ðŸ” Steps:
nums = ["011", 
        "110", 
        "101"]

res = flip(nums[0][0]) + 
      flip(nums[1][1]) + 
      flip(nums[2][2])

â†’ res = "100"
Each bit is different from corresponding bit in each string â†’ âœ”ï¸ unique.

ðŸ§¾ Complexity:
â±ï¸ Time: O(n)
ðŸ§  Space: O(n)
ðŸ¥‡ Always preferred â€” works for any n


string findDifferentBinaryString(vector<string>& nums) {
    string res = "";
    for (int i = 0; i < nums.size(); i++) {
        res += (nums[i][i] == '0') ? '1' : '0';
    }
    return res;
}




